OS Project Two Report

Group Members: Raj Patel, Derek Sagun, Luiz Rivera

	For the second project, a lot of the difficulty stemmed from understanding what needed to be done and how exactly to implement it. After understanding the project, it was not too difficult, however some challenges presented in the LKM were too difficult to overcome. Our project compiles with version 4.15.0-29 Linux Headers. The user application is a terminal interface that runs an endless while loop, constantly asking the user which operation they would like to do, whether it be create, encrypt, decrypt, destroy, or configure. In order to run our program, from the git repository, the following commands need to be run: make, make user, dmesg to find the major number, mknod /dev/cryptctl c <major number> 0. And then after that, you can run ./user_app, which executes our program. If receiving stard.h missing error on make run these commands→ 
$ cd /lib/modules/$(uname -r)/build/include
$ sudo ln -s $(gcc -print-file-name=include)/stdarg.h


For our implementations of encrypt and decrypt we used the translated the formula given to us from the wiki page into C code. We used each letter's ASCII value in order to get the new value of the encrypted or decrypted message
. However, we reach a complication when implementing it with lowercase letters. We solved this by making each lowercase letter capital, running the encyrption or decryption code on it, then returning the new output into a lowercase letter. A bug that we ran into was when we entered message and key and Clicked 'Enter'. it caused there to be a new line character at the end of each of them,making the size, encyrption, and decyrption wrong. We fixed this by taking the length of each of them and subtracting by 1. THis allowed our for loops, which were looping the message and key length, to never reach the new line character.

After this, you can run create once to create the first encrypt/decrypt pair successfully. Our program can only create one pair successfully; subsequent create calls will not create more file pairs. Delete also does not work. However, encrypt and decrypt and configure work perfectly on the file pairs for encrypt and decrypt. Create() has to bee called first and only works for id 0. Then conf() can be called only on id 0 which sets the key, from there call encyrpt() then decrypt(). For our implementations of these, we sets the a userStruct argument, which contains things like the message buffer and key buffer to the lkm on every ioctl call. From here depending on the id from that userStruct, the lkm functions can go the the local data structure (devices []) and set the corresponding file pointer for the two open file pairs ( for create()), or set the key buffer (for conf), or set the encrypted buffer and decrypted buffer (for decyprt and encrypt) for the corresponding index in the devices array.


We initially created the first pair, and then sought to complete encrypt and decrypt as it is worth a lot of points, more than being able to dynamically create and destroy the encryption devices. The difficulties in the project especially involved dealing with the intricacies of the LKM, and not being able to do many things one can do so easily in the user space. An example of this was understanding all of the functions to create the first cryptctl device, and so on. Moreover, a lot of issues that caused the VM to crash were frustrating. To expedite the process, some of our group members used a VirtualBox with Ubuntu so that we could restart our own VM’s if need be. We obviously also tested on the actual VM as well to make sure that our project compiled there too. 
